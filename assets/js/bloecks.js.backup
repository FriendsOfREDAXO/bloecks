/**
 * BLOECKS - REDAXO Backend Drag & Drop System with Wrapper Support
 * Based on SortableJS for modern drag & drop functionality
 * Now supports slice_columns-style wrappers and toast notifications
 */

var BLOECKS = (function($) {
    'use strict';
    
    var sortableInstances = [];
    
    // Toast notification system
    var toastContainer = null;
    var toastCounter = 0;
    
    function createToastContainer() {
        if (toastContainer) {
            return toastContainer;
        }
        
        toastContainer = document.createElement('div');
        toastContainer.className = 'bloecks-toast-container';
        toastContainer.style.cssText = `
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            pointer-events: none;
        `;
        document.body.appendChild(toastContainer);
        return toastContainer;
    }
    
    function showToast(message, type, duration) {
        type = type || 'success';
        duration = duration || 4000;
        
        var toastId = 'bloecks-toast-' + (++toastCounter);
        return showToastWithId(message, type, duration, toastId);
    }
    
    function showToastWithId(message, type, duration, toastId) {
        type = type || 'success';
        duration = duration || 4000;
        
        var container = createToastContainer();
        var toast = document.createElement('div');
        
        toast.id = toastId;
        toast.className = 'bloecks-toast bloecks-toast-' + type;
        toast.style.cssText = `
            background: ${type === 'success' ? '#28a745' : type === 'warning' ? '#ffc107' : type === 'info' ? '#17a2b8' : '#dc3545'};
            color: white;
            padding: 20px 26px;
            margin-bottom: 12px;
            border-radius: 8px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.25);
            transform: scale(0.8);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: auto;
            cursor: pointer;
            max-width: 500px;
            min-width: 350px;
            word-wrap: break-word;
            font-size: 16px;
            line-height: 1.5;
            position: relative;
            text-align: center;
            font-weight: 500;
        `;
        
        toast.innerHTML = `
            <div style="display: flex; align-items: flex-start; gap: 8px;">
                <div style="flex: 1;">${message}</div>
                <button onclick="BLOECKS.closeToast('${toastId}')" 
                        style="background: none; border: none; color: white; font-size: 18px; 
                               line-height: 1; cursor: pointer; padding: 0; margin: -2px 0 0 0;">×</button>
            </div>
        `;
        
        container.appendChild(toast);
        
        // Trigger animation
        setTimeout(function() {
            toast.style.transform = 'scale(1)';
            toast.style.opacity = '1';
        }, 10);
        
        // Auto remove
        setTimeout(function() {
            removeToast(toastId);
        }, duration);
        
        // Click to close
        toast.addEventListener('click', function() {
            removeToast(toastId);
        });
        
        return toastId; // Return the ID so it can be removed later
    }
    
    function removeToast(toastId) {
        var toast = document.getElementById(toastId);
        if (toast) {
            toast.style.transform = 'scale(0.8)';
            toast.style.opacity = '0';
            setTimeout(function() {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }
    }
    
    function closeToast(toastId) {
        removeToast(toastId);
    }
    
    function initDragDrop() {
        // Check if drag & drop is enabled in PHP config
        var bloecksConfig = rex.bloecks || {};
        if (!bloecksConfig.enable_drag_drop) {
            return;
        }
        
        // Find the parent container that holds all wrapper elements
        var mainContainer = document.body;
        
        // Check if we have drag elements
        var dragElements = mainContainer.querySelectorAll('.bloecks-dragdrop');
        
        if (dragElements.length === 0) {
            return;
        }
        
        // Find the common parent of all drag elements
        var commonParent = dragElements[0].parentNode;
        while (commonParent && commonParent !== document.body) {
            var allInParent = true;
            dragElements.forEach(function(el) {
                if (!commonParent.contains(el)) {
                    allInParent = false;
                }
            });
            if (allInParent) break;
            commonParent = commonParent.parentNode;
        }
        
        try {
            var sortable = Sortable.create(commonParent, {
                draggable: '.bloecks-dragdrop',
                handle: '.bloecks-drag-handle',
                animation: 150,
                ghostClass: 'bloecks-sortable-ghost',
                chosenClass: 'bloecks-sortable-chosen',
                dragClass: 'bloecks-dragging',
                
                onStart: function(evt) {
                    evt.item.classList.add('bloecks-dragging');
                },
                
                onEnd: function(evt) {
                    evt.item.classList.remove('bloecks-dragging');
                    
                    if (evt.oldIndex !== evt.newIndex) {
                        updateSliceOrder(evt);
                    }
                }
            });
            
            sortableInstances.push(sortable);
            
        } catch (error) {
            console.error('BLOECKS: Error creating sortable:', error);
        }
    }
    
    function updateSliceOrder(evt) {
        var draggedElement = evt.item;
        var sliceId = draggedElement.getAttribute('data-slice-id');
        var articleId = draggedElement.getAttribute('data-article-id');
        var clangId = draggedElement.getAttribute('data-clang-id');
        
        if (!sliceId || !articleId || !clangId) {
            console.error('BLOECKS: Missing data attributes for slice reorder');
            return;
        }
        
        // Get all slice IDs in new order from wrapper elements
        var sliceOrder = [];
        var containers = document.querySelectorAll('.bloecks-dragdrop');
        containers.forEach(function(container) {
            var id = container.getAttribute('data-slice-id');
            if (id) {
                sliceOrder.push(id);
            }
        });
        
        // AJAX request to update order using rex_api_bloecks
        $.ajax({
            url: 'index.php',
            type: 'POST',
            dataType: 'json',
            data: {
                'rex-api-call': 'bloecks',
                'function': 'update_order',
                'article': articleId,
                'clang': clangId,
                'order': JSON.stringify(sliceOrder)
            },
            success: function(response) {
                // Show success toast instead of relying on page reload
                BLOECKS.showToast('Slice-Reihenfolge aktualisiert', 'success', 3000);
                
                // Just reinitialize without page reload for better UX
                setTimeout(function() {
                    destroy();
                    initDragDrop();
                }, 100);
            },
            error: function(xhr, status, error) {
                console.error('BLOECKS: Failed to update order', error);
                BLOECKS.showToast('Fehler beim Aktualisieren der Reihenfolge', 'error', 5000);
                // Revert visual changes on error
                evt.to.insertBefore(evt.item, evt.to.children[evt.oldIndex]);
            }
        });
    }
    
    function destroy() {
        sortableInstances.forEach(function(sortable) {
            if (sortable && typeof sortable.destroy === 'function') {
                sortable.destroy();
            }
        });
        sortableInstances = [];
        
        // Remove initialization markers
        document.querySelectorAll('.bloecks-initialized').forEach(function(el) {
            el.classList.remove('bloecks-initialized');
        });
    }
    
    // Initialize when DOM is ready
    $(document).ready(function() {
        initDragDrop();
        checkForMessages();
        initCopyPasteHandlers();
    });
    
    // Check for BLOECKS messages and show as toasts
    function checkForMessages() {
        // Look for BLOECKS success/warning/error messages in rex-page-main-content
        var mainContent = document.getElementById('rex-page-main-content');
        if (!mainContent) {
            mainContent = document.body;
        }
        
        // Check for success messages
        var successMessages = mainContent.querySelectorAll('.alert-success');
        successMessages.forEach(function(alert) {
            var text = alert.textContent.trim();
            if (text.includes('kopiert') || text.includes('eingefügt') || text.includes('ausgeschnitten')) {
                showToast(text, 'success');
                // Hide the original alert after showing toast
                alert.style.display = 'none';
            }
        });
        
        // Check for warning messages
        var warningMessages = mainContent.querySelectorAll('.alert-warning');
        warningMessages.forEach(function(alert) {
            var text = alert.textContent.trim();
            if (text.includes('bloecks') || text.includes('Berechtigung') || text.includes('Clipboard')) {
                showToast(text, 'warning', 6000);
                alert.style.display = 'none';
            }
        });
        
        // Check for error messages
        var errorMessages = mainContent.querySelectorAll('.alert-danger, .alert-error');
        errorMessages.forEach(function(alert) {
            var text = alert.textContent.trim();
            if (text.includes('bloecks') || text.includes('Fehler')) {
                showToast(text, 'error', 8000);
                alert.style.display = 'none';
            }
        });
        
        // Test Toast - show once on page load (remove this later)
        // if (!window.bloecksToastTested) {
        //     window.bloecksToastTested = true;
        //     setTimeout(function() {
        //         showToast('BLOECKS Toast-System geladen!', 'success', 3000);
        //     }, 1000);
        // }
    }
    
    // Check for scroll target after page reload
    function checkForScrollTarget() {
        console.log('Checking for scroll target in sessionStorage');
        var scrollTarget = sessionStorage.getItem('bloecks_scroll_target');
        console.log('Found scroll target:', scrollTarget);
        
        if (scrollTarget) {
            // Clear the target immediately to prevent repeated scrolling
            sessionStorage.removeItem('bloecks_scroll_target');
            
            // Use shorter delays for PJAX-optimized system
            var delay = 200; // Fixed short delay for PJAX
            console.log('Using delay:', delay + 'ms for scroll target');
            
            setTimeout(function() {
                console.log('Looking for slice with ID:', scrollTarget);
                var targetSlice = findSliceById(scrollTarget);
                
                if (targetSlice) {
                    console.log('Found target slice, scrolling to it');
                    scrollToSlice(targetSlice);
                } else {
                    console.log('Target slice not found, available slices:');
                    
                    // Debug: show all slices with their IDs
                    var allSlices = document.querySelectorAll('.rex-slice, .bloecks-dragdrop, .panel, form');
                    console.log('Total slices found:', allSlices.length);
                    
                    for (var i = 0; i < allSlices.length; i++) {
                        var slice = allSlices[i];
                        var sliceIdInput = slice.querySelector('input[name="slice_id"]');
                        var sliceId = sliceIdInput ? sliceIdInput.value : 'no-id';
                        console.log('Slice', i + ':', {
                            element: slice,
                            id: sliceId,
                            classes: slice.className,
                            tag: slice.tagName
                        });
                    }
                }
            }, delay);
        } else {
            console.log('No scroll target found in sessionStorage');
        }
    }    function findSliceById(sliceId) {
        console.log('Looking for slice ID:', sliceId);
        
        // First, try to find slice_id input fields (most reliable in REDAXO)
        var sliceInputs = document.querySelectorAll('input[name="slice_id"]');
        console.log('Found slice_id inputs:', sliceInputs.length);
        
        for (var i = 0; i < sliceInputs.length; i++) {
            var input = sliceInputs[i];
            console.log('Checking input value:', input.value, 'against target:', sliceId);
            if (input.value == sliceId) {
                console.log('Found matching slice_id input!');
                // Find the parent slice container
                var sliceContainer = input.closest('.rex-slice, .panel, .bloecks-dragdrop, form');
                if (sliceContainer) {
                    console.log('Found slice container:', sliceContainer);
                    return sliceContainer;
                }
                return input.parentNode;
            }
        }
        
        // Try other selectors as fallback
        var selectors = [
            '#slice' + sliceId,
            '[data-slice-id="' + sliceId + '"]',
            '.rex-slice[data-slice-id="' + sliceId + '"]',
            '.bloecks-dragdrop[data-slice-id="' + sliceId + '"]'
        ];
        
        for (var j = 0; j < selectors.length; j++) {
            var element = document.querySelector(selectors[j]);
            if (element) {
                console.log('Found slice with selector:', selectors[j]);
                return element;
            }
        }
        
        console.log('No slice found for ID:', sliceId);
        return null;
    }
    
    function scrollToSlice(sliceElement) {
        if (!sliceElement) {
            console.log('No slice element provided for scrolling');
            return;
        }
        
        console.log('Scrolling to slice element:', sliceElement);
        console.log('Element tag:', sliceElement.tagName);
        console.log('Element classes:', sliceElement.className);
        console.log('Element is visible:', sliceElement.offsetParent !== null);
        console.log('Element dimensions:', {
            width: sliceElement.offsetWidth,
            height: sliceElement.offsetHeight,
            top: sliceElement.offsetTop
        });
        
        // Make sure the element is visible and rendered
        if (sliceElement.offsetParent === null) {
            console.log('Element is not visible, cannot scroll');
            return;
        }
        
        // Scroll to the slice element with some offset
        setTimeout(function() {
            try {
                var rect = sliceElement.getBoundingClientRect();
                var targetPosition = rect.top + window.pageYOffset - 100; // 100px offset from top
                
                console.log('Current scroll position:', window.pageYOffset);
                console.log('Element rect:', rect);
                console.log('Target scroll position:', targetPosition);
                
                // Make sure we have a valid position
                if (targetPosition < 0) targetPosition = 0;
                
                window.scrollTo({
                    top: targetPosition,
                    behavior: 'smooth'
                });
                
                console.log('Scroll command executed');
                
                // Find the .rex-slice element inside the wrapper for animation
                var rexSliceElement = sliceElement.querySelector('.rex-slice');
                if (!rexSliceElement) {
                    // If no .rex-slice found, check if the element itself is .rex-slice
                    if (sliceElement.classList.contains('rex-slice')) {
                        rexSliceElement = sliceElement;
                    }
                }
                
                if (rexSliceElement) {
                    console.log('Animating rex-slice element:', rexSliceElement);
                    
                    // Enhanced highlight effect with zoom and glow on .rex-slice
                    rexSliceElement.style.transition = 'all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                    rexSliceElement.style.transform = 'scale(1.02)';
                    rexSliceElement.style.boxShadow = '0 8px 32px rgba(40, 167, 69, 0.4), 0 0 0 3px rgba(40, 167, 69, 0.3)';
                    rexSliceElement.style.backgroundColor = 'rgba(40, 167, 69, 0.08)';
                    rexSliceElement.style.borderRadius = '8px';
                    rexSliceElement.style.position = 'relative';
                    rexSliceElement.style.zIndex = '10';
                    
                    // First phase: zoom in and glow (400ms)
                    setTimeout(function() {
                        rexSliceElement.style.transform = 'scale(1.01)';
                        rexSliceElement.style.boxShadow = '0 6px 24px rgba(40, 167, 69, 0.3), 0 0 0 2px rgba(40, 167, 69, 0.2)';
                    }, 200);
                    
                    // Second phase: start fading (after 800ms)
                    setTimeout(function() {
                        rexSliceElement.style.transition = 'all 0.8s ease-out';
                        rexSliceElement.style.transform = 'scale(1)';
                        rexSliceElement.style.boxShadow = '0 2px 8px rgba(40, 167, 69, 0.1)';
                        rexSliceElement.style.backgroundColor = 'rgba(40, 167, 69, 0.02)';
                    }, 800);
                    
                    // Final phase: complete fade out (after 1.6s)
                    setTimeout(function() {
                        rexSliceElement.style.transform = '';
                        rexSliceElement.style.boxShadow = '';
                        rexSliceElement.style.backgroundColor = '';
                        rexSliceElement.style.borderRadius = '';
                        rexSliceElement.style.position = '';
                        rexSliceElement.style.zIndex = '';
                        // Reset transition after animation
                        setTimeout(function() {
                            rexSliceElement.style.transition = '';
                        }, 800);
                    }, 1600);
                } else {
                    console.log('No .rex-slice element found for animation');
                }
                
            } catch (e) {
                console.error('Error during scrolling:', e);
            }
        }, 50);
    }
    
    // Reinitialize after PJAX requests
    $(document).on('rex:ready', function() {
        console.log('rex:ready event fired');
        // Always reinitialize on content pages
        if (window.location.href.includes('page=content')) {
            destroy();
            setTimeout(function() {
                initDragDrop();
                checkForMessages();
                initCopyPasteHandlers();
                checkForScrollTarget(); // Add this call!
            }, 100);
        }
    });
    
    // Also listen for pjax:end as backup
    $(document).on('pjax:end', function() {
        console.log('pjax:end event fired');
        if (window.location.href.includes('page=content')) {
            destroy();
            setTimeout(function() {
                initDragDrop();
                checkForMessages();
                initCopyPasteHandlers();
                checkForScrollTarget(); // Add this call!
            }, 150);
        }
    });
    
    // Listen specifically for PJAX events on the main content container
    $(document).on('pjax:success', '#rex-js-page-main-content', function(event) {
        console.log('PJAX success on main content container');
        if (window.location.href.includes('page=content')) {
            setTimeout(function() {
                checkForScrollTarget();
            }, 250);
        }
    });
    
    // Listen for PJAX complete event
    $(document).on('pjax:complete', '#rex-js-page-main-content', function(event) {
        console.log('PJAX complete on main content container');
        if (window.location.href.includes('page=content')) {
            destroy();
            setTimeout(function() {
                initDragDrop();
                checkForMessages();
                initCopyPasteHandlers();
                checkForScrollTarget();
            }, 100);
        }
    });
    
    // Additional event listeners for real page loads (not just PJAX)
    $(document).ready(function() {
        console.log('Document ready - checking for scroll target');
        if (window.location.href.includes('page=content')) {
            setTimeout(function() {
                checkForScrollTarget();
            }, 100);
        }
    });
    
    // Also listen for window load event (after all resources loaded)
    $(window).on('load', function() {
        console.log('Window load event - checking for scroll target');
        if (window.location.href.includes('page=content')) {
            setTimeout(function() {
                checkForScrollTarget();
            }, 200);
        }
    });
    
    // Native DOM events for better compatibility
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOMContentLoaded - checking for scroll target');
            if (window.location.href.includes('page=content')) {
                setTimeout(function() {
                    checkForScrollTarget();
                }, 100);
            }
        });
    } else {
        // DOM already loaded
        console.log('DOM already ready - checking for scroll target immediately');
        if (window.location.href.includes('page=content')) {
            setTimeout(function() {
                checkForScrollTarget();
            }, 50);
        }
    }
    
    // Initialize copy/paste handlers for AJAX operations
    function initCopyPasteHandlers() {
        // Handle copy/cut buttons
        $(document).off('click', '.bloecks-copy, .bloecks-cut').on('click', '.bloecks-copy, .bloecks-cut', function(e) {
            e.preventDefault();
            
            var $this = $(this);
            var action = $this.hasClass('bloecks-copy') ? 'copy' : 'cut';
            var sliceId = $this.data('slice-id');
            
            if (!sliceId) {
                showToast('Fehler: Slice-ID nicht gefunden', 'error');
                return;
            }
            
            performCopyPasteAction(action, { slice_id: sliceId });
        });
        
        // Handle paste buttons  
        $(document).off('click', '.bloecks-paste').on('click', '.bloecks-paste', function(e) {
            e.preventDefault();
            
            var $this = $(this);
            var targetSlice = $this.data('target-slice') || null;
            var articleId = $this.data('article-id');
            var clangId = $this.data('clang-id');
            var ctypeId = $this.data('ctype-id') || 1;
            
            if (!articleId || !clangId) {
                showToast('Fehler: Artikel-Parameter fehlen', 'error');
                return;
            }
            
            performCopyPasteAction('paste', {
                bloecks_target: targetSlice,
                article_id: articleId,
                clang: clangId,
                ctype: ctypeId
            });
        });
    }
    
    function performCopyPasteAction(action, params) {
        // Show loading toast with unique ID
        var loadingToastId = 'bloecks-loading-' + Date.now();
        var loadingToast = showToastWithId('Wird verarbeitet...', 'info', 30000, loadingToastId);
        
        var data = {
            'function': action,  // Use 'function' parameter like the existing API
            'rex-api-call': 'bloecks'  // Use the existing API
        };
        
        // Merge parameters
        for (var key in params) {
            data[key] = params[key];
        }
        
        $.ajax({
            url: 'index.php',
            type: 'POST',
            dataType: 'json',
            data: data,
            success: function(response) {
                // Remove loading toast first
                removeToast(loadingToastId);
                
                console.log('BLOECKS Response:', response); // Debug
                
                if (response.success) {
                    showToast(response.message, 'success', 3000); // Shorter duration
                    
                    // Only reload for paste actions - copy/cut don't need reload
                    if (action === 'paste' && response.reload_needed) {
                        // Store scroll target in sessionStorage for after reload
                        if (response.scroll_to_slice && response.new_slice_id) {
                            sessionStorage.setItem('bloecks_scroll_target', response.new_slice_id);
                        }
                        
                        // Shorter delay for faster UX
                        setTimeout(function() {
                            // Use the correct PJAX method like REDAXO core does
                            console.log('Using PJAX reload like REDAXO core');
                            $.pjax({
                                url: window.location.href,
                                container: '#rex-js-page-main-content',
                                fragment: '#rex-js-page-main-content',
                                push: false // Important: don't push to history
                            });
                        }, 800); // Shorter wait time
                    }
                    
                    // For copy/cut, just update the button states without reload
                    if (action === 'copy' || action === 'cut') {
                        // Update UI to show the action was successful
                        // You can add visual feedback here if needed
                        console.log(action + ' operation completed successfully');
                    }
                } else {
                    showToast(response.message || 'Unbekannter Fehler', 'error');
                }
            },
            error: function(xhr, status, error) {
                // Remove loading toast first
                removeToast(loadingToastId);
                showToast('Netzwerk-Fehler bei der Verarbeitung', 'error');
                console.error('BLOECKS AJAX Error:', error);
            }
        });
    }
    
    // Public API
    return {
        init: initDragDrop,
        destroy: destroy,
        showToast: showToast,
        closeToast: closeToast,
        checkForMessages: checkForMessages,
        checkForScrollTarget: checkForScrollTarget,
        initCopyPasteHandlers: initCopyPasteHandlers,
        version: '2.4.0'
    };
    
})(jQuery);
